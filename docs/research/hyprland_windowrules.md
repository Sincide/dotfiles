Mastering Window Behavior in Hyprland: A Comprehensive Guide to Configuring Floating and Centered ApplicationsIntroductionThis report provides a comprehensive analysis and definitive solution for configuring window behavior within the Hyprland Wayland compositor. The primary objective is to address the specific requirement of launching an application, identified as 'Evil Launcher', in a floating window that is automatically centered on the screen upon creation. This common customization task serves as a practical entry point into the broader, more powerful capabilities of Hyprland's window management system.The core mechanism for achieving this level of control is Hyprland's declarative windowrule system. This system allows for the definition of persistent policies that dictate how specific windows should be treated based on their properties, such as title, application class, or state. This declarative approach, where the desired end-state is defined in a configuration file, stands in contrast to imperative methods, which involve issuing one-time commands to manipulate windows that are already open.To provide a complete and expert-level understanding, this report will proceed in a structured manner. It will begin by deconstructing the fundamental syntax and concepts of the window rule system, including a critical examination of how to correctly identify target windows. It will then present the direct, optimized solution to the stated problem. Following this, the analysis will expand to cover advanced techniques, common troubleshooting scenarios, and the nuances of using regular expressions for more complex matching. Finally, the report will explore alternative paradigms, including the use of hyprctl dispatchers for on-demand manipulation and event-driven scripting via the Hyprland IPC socket, placing the windowrule system within the full context of the compositor's capabilities. The result is a holistic guide intended to empower the user with a deep, transferable mastery of window management in Hyprland.Section 1: The Foundation: Deconstructing Hyprland's Window Rule SystemA robust understanding of Hyprland's window rule system is paramount for effective configuration. This system is the primary interface for defining how the compositor automatically handles windows as they are created. Its logic is powerful but requires precision in both syntax and targeting.1.1 The Anatomy of a windowruleThe fundamental building block of automated window management in Hyprland is the windowrule. Its syntax is designed to be both concise and expressive, linking a specific action to a set of conditions.The general syntax is defined as follows 1:windowrule=RULE,PARAMETERSRULE: This specifies the action or state to be applied to the window. Multiple rules can be chained together in a single line, separated by commas. Examples include float, center, size, and workspace.PARAMETERS: This is a comma-separated list of one or more conditions used to identify the target window(s). Each parameter consists of a key (e.g., title, class) and a value, which is typically a regular expression.A point of potential confusion for users consulting various online resources is the existence of two keywords: windowrule and windowrulev2. Historically, windowrule was a simpler system, while windowrulev2 was introduced to provide more flexible matching based on multiple properties.2 However, in modern versions of Hyprland, the functionality of windowrulev2 has been fully integrated into the standard windowrule keyword. The windowrulev2 keyword is now deprecated but is maintained as an alias for backward compatibility with older configuration files.4 Therefore, for all new configurations, it is best practice to exclusively use the windowrule keyword, as it represents the current, unified, and canonical syntax.1.2 Identifying Your Target: The Critical Role of hyprctl clientsThe effectiveness of any windowrule hinges entirely on the accuracy of its parameters. To acquire the necessary information for these parameters, Hyprland provides a command-line utility, hyprctl, which serves as the primary tool for interacting with the running compositor. The specific command hyprctl clients is indispensable for this task, as it outputs a detailed list of all open windows and their properties.2A typical workflow involves opening the target application and then running hyprctl clients in a terminal. The output will contain crucial fields such as initialTitle, initialClass, title, and class.A frequent and significant source of error in writing window rules stems from a misunderstanding of how and when different types of rules are applied. Hyprland's rules are categorized as either static or dynamic.Static rules are evaluated only once, at the exact moment a window is created (or "mapped"). These include rules that define a window's fundamental geometry and state, such as float, center, size, move, and workspace.Dynamic rules can be re-evaluated and applied whenever a window's properties change. These typically relate to aesthetics, such as opacity or bordercolor.1This distinction has a profound implication: static rules are matched against a window's initial properties, not its current ones.1 The hyprctl clients output provides both the initial and current values, for example, initialTitle and title. A common failure scenario occurs when a user attempts to apply a static rule like float based on a window's current title, which may have changed since the window was first opened. For instance, a web browser might launch with an initialTitle of "Mozilla Firefox" but later update its title to "My Document - Google Docs - Mozilla Firefox" after a page loads. A static rule written to match title:(.*Google Docs.*) would fail because, at the moment of the rule's evaluation, the title did not contain that string. The rule must instead target the initialTitle or initialClass to succeed. This single concept is the key to debugging a majority of non-functioning static window rules.1.3 Essential Parameters for Window MatchingTo construct precise and effective rules, it is necessary to be familiar with the available matching parameters. While numerous parameters exist, a core set is used in the majority of configurations. The following table details these essential parameters, providing a quick reference for building window rules.ParameterDescriptionData TypeExample UsageSource ReferencetitleMatches the window's current title. Best used for dynamic rules that react to title changes.Regextitle:(.*- Youtube)1initialTitleMatches the window's title at the moment of creation. Essential for static rules.RegexinitialTitle:^(Evil Launcher)$2classMatches the window's current class name, as reported by the application.Regexclass:^(kitty)$1initialClassMatches the window's class name at the moment of creation. Essential for static rules.RegexinitialClass:^(kitty)$2floatingMatches if the window is currently in a floating state. Used to apply rules only to floating windows.0 or 1floating:12xwaylandMatches if the window is an XWayland client, as opposed to a native Wayland client.0 or 1xwayland:12By leveraging hyprctl clients to find the correct initialTitle or initialClass and applying the appropriate parameters, a user can reliably target any application for automated window management.Section 2: The Definitive Solution: Forcing 'Evil Launcher' to Float and CenterWith a solid understanding of the windowrule system, constructing the specific configuration to make the 'Evil Launcher' application float and center upon launch is a straightforward process. It involves combining two primary static rules, float and center, and targeting the window by its title.2.1 The Building Blocks: float and centerThe two essential rules for this task are float and center. Each serves a distinct purpose, and their interaction is critical.The float Directive: This is a static rule that instructs Hyprland to exempt the matched window from the tiling layout. Instead of being placed in a tile, the window will be created as a floating layer that can be freely moved and resized above the tiled windows.1 This is the prerequisite for any subsequent positioning or sizing rules.The center Directive and its Dependency: This static rule positions a window in the center of the monitor it appears on.1 However, a crucial aspect of its behavior is that it only affects windows that are already floating.1 Attempting to apply a center rule to a window that remains tiled will have no effect. This is a common point of failure for new users who might logically write a rule like windowrule = center, class:my-app and expect a centered result. The compositor's logic is effectively: "If this new window is floating, then center it." If the window is not floating, the condition is not met, and the rule is ignored. Therefore, the float rule must be applied for the center rule to function as intended.62.2 Assembling the ConfigurationThe user has specified that the application window is identifiable by the title 'Evil Launcher'. To ensure a precise match and avoid accidentally targeting other windows that might contain this phrase as a substring, it is best practice to use regular expression anchors. The caret (^) matches the beginning of the string, and the dollar sign ($) matches the end. Thus, the correct parameter for targeting is title:^(Evil Launcher)$. Since this is a static title for a launcher, using title or initialTitle is functionally equivalent, but using initialTitle is technically more correct for a static rule.There are two valid methods for structuring the rules in the hyprland.conf file.Method 1: The Combined Single-Line Rule (Preferred)Hyprland's windowrule syntax allows for multiple rules to be specified in a single line before the parameters. This is the most concise and efficient method.Code snippet#
# hyprland.conf
#
# Preferred Method: Combines float and center rules for the 'Evil Launcher'
# into a single, efficient line.
windowrule = float, center, initialTitle:^(Evil Launcher)$
This single line clearly states that any window with the exact initial title 'Evil Launcher' should be made to float and then be centered. This is the recommended approach for its clarity and brevity.Method 2: The Explicit Multi-Line Rule (Alternative)For users who prefer to separate individual actions for organizational purposes or for configurations with many complex rules, it is also possible to define each rule on a separate line. Hyprland processes the configuration file from top to bottom, applying all matching rules.7Code snippet#
# hyprland.conf
#
# Alternative Method: Defines float and center rules on separate lines.
# This is functionally identical to the single-line method but can be
# easier to read in complex configurations.
windowrule = float, initialTitle:^(Evil Launcher)$
windowrule = center, initialTitle:^(Evil Launcher)$
This approach achieves the exact same result as the single-line method. The window is first matched and made to float, and then it is matched again and centered. While slightly more verbose, some users may find this style more maintainable for very large rule sets.102.3 A Critical Addition: Controlling Initial Geometry with sizeWhile the user's request was limited to floating and centering, a common related requirement for launchers and dialog boxes is to control their initial size. A floating window that occupies the entire screen is rarely useful. The windowrule system provides the size directive for this purpose.The size rule, like center, is a static rule that only applies to floating windows.1 Its syntax is size [x][y], where x and y can be specified in pixels or as a percentage of the monitor's dimensions.Fixed Size: size 800 600 would create a window 800 pixels wide and 600 pixels high.Percentage Size: size 50% 60% would create a window that is 50% of the monitor's width and 60% of its height.By incorporating the size rule, a more robust and practical configuration can be achieved. The final, recommended configuration combines all three directives into a single line, providing a complete solution that addresses both the stated and likely unstated needs of the user.Code snippet#
# hyprland.conf
#
# Complete and Recommended Rule for 'Evil Launcher'
# This rule ensures the application always launches as a floating window,
# centered on the screen, with a predictable size of 50% of the monitor's
# width and 40% of its height.
windowrule = float, center, size 50% 40%, initialTitle:^(Evil Launcher)$
This single, well-crafted line in the hyprland.conf file provides a complete, production-ready solution that is both idiomatic to Hyprland's design philosophy and robust in its execution.Section 3: Advanced Techniques and TroubleshootingWhile the primary solution is often straightforward, real-world usage can present edge cases and unexpected behavior. Mastering Hyprland involves understanding not just the correct syntax but also how to debug issues when they arise and how to handle more complex scenarios.3.1 The Power of Regular Expressions (Regex) in Window TitlesThe 'Evil Launcher' example benefits from a simple, static title. However, many applications, particularly web browsers and media players, have dynamic titles that change based on their content. The windowrule system's reliance on regular expressions provides the necessary power to handle these cases.For example, to apply a rule to any browser window currently displaying a YouTube video, a simple string match would be insufficient. The title could be anything from "Video A - YouTube" to "Video B - YouTube". A regular expression can capture this pattern. The official documentation provides an excellent example 1:windowrule = opacity 0.8, title:(.*)(- Youtube)In this rule, (.*)(- Youtube) matches any sequence of characters (.*) followed by the literal string - Youtube. This allows the rule to apply to any YouTube video window, regardless of the specific video title. This technique is invaluable for creating rules that target content rather than just applications.3.2 Common Pitfalls and the Debugging ChecklistWhen a window rule does not work as expected, the cause is often one of a few common mistakes. A systematic debugging process can quickly identify the problem.Verify Case-Sensitivity: Window rules are strictly case-sensitive. A rule targeting class:firefox will not match a window whose class is Firefox. It is essential to use the exact case as reported by hyprctl clients.1Reload the Configuration: Hyprland does not automatically detect changes to its configuration file. After editing hyprland.conf, the configuration must be reloaded for the changes to take effect. This is typically done with a pre-configured keybinding (often SUPER + SHIFT + R) or by running hyprctl reload in a terminal.11Confirm initialTitle vs. title: As detailed previously, this is the most common point of failure for static rules (float, center, size). If a static rule is not applying, the first step should be to check if it is incorrectly targeting the title parameter instead of initialTitle or initialClass.1Ensure Full Regex Matching: A significant change introduced around Hyprland v0.46.0 requires that regular expressions fully match the window value, whereas older versions performed a substring match.1 This is a critical "gotcha" for users referencing older configurations or tutorials. For example, an old rule windowrule = float, class:kitty might have worked by matching the substring "kitty" within a longer class name. In modern Hyprland, this will fail. The rule must be updated to provide a full match, such as class:^(kitty)$ for an exact match or class:(.*kitty.*) to replicate the old substring search behavior.13.3 Addressing Inconsistencies: The size Rule Race ConditionIn some cases, a correctly written size or center rule may apply inconsistently. The window might launch with the correct dimensions on some occasions and with a default floating size on others. This behavior is often indicative of a "race condition".12A race condition occurs when the outcome of a process depends on the unpredictable timing of independent events. In this context, Hyprland applies the window rule as soon as the window is mapped. However, the application itself might have its own internal logic that attempts to set its size moments after it has been mapped. If the application's resize request happens after Hyprland's rule has been applied, the application's preference will win, effectively overriding the windowrule.12 This is more common with complex applications or those running under compatibility layers like XWayland.While there is no perfect solution for all race conditions, Hyprland provides a directive that can help: persistentsize. This rule, when applied to a floating window, instructs Hyprland to remember the window's size when it was last closed and re-apply it on the next launch.1Code snippet# Example of using persistentsize to combat inconsistent sizing
windowrule = float, center, persistentsize, initialClass:^(Thunar)$
This can create more predictable behavior for applications prone to overriding their initial geometry. Acknowledging the existence of such race conditions demonstrates an expert understanding of the practical limitations and complexities of window management systems.Section 4: Alternative Paradigms: Dispatchers and Event-Driven ScriptingWhile windowrule is the primary tool for defining the initial state of windows, Hyprland provides more advanced mechanisms for manipulating windows after they have been created and for implementing logic that goes beyond the scope of the rule system. Understanding these alternative paradigms—dispatchers and event-driven scripting—is essential for complete mastery.4.1 Rules vs. Dispatchers: A Tale of Two ContextsThe fundamental difference between windowrule and hyprctl dispatch lies in their operational paradigm: declarative versus imperative.Declarative (windowrule): This approach defines a policy or a desired end-state in a configuration file. A rule like windowrule = float, class:kitty states, "It is a policy that any window of the class 'kitty' should be floating." The system then automatically enforces this policy whenever a new kitty window is created. It is a "set it and forget it" approach for automated, consistent behavior.Imperative (hyprctl dispatch): This approach involves issuing a direct, one-time command to perform an action. A command like hyprctl dispatch togglefloating states, "Take the currently focused window and toggle its floating state now." This action is typically bound to a key or executed from a script. It is a manual, on-demand method for manipulating existing windows.14Choosing between them is a matter of context. For defining how a window should always launch, a windowrule is the correct tool. For changing the state of an already-open window with a keypress, a dispatcher is the correct tool.4.2 Practical hyprctl Scripting for On-Demand ActionsThe hyprctl utility can be used to execute any of Hyprland's dispatchers from the command line, making it trivial to bind complex actions to a single key. Multiple commands can be chained together in a single exec call.For instance, to create a keybinding that takes any currently focused window, makes it floating (or tiled if already floating), and then centers it, one could chain the togglefloating and centerwindow dispatchers. The hyprctl --batch flag is particularly useful for this, as it executes a series of commands separated by semicolons.6Code snippet#
# hyprland.conf
#
# Example keybind to make any active window floating and centered on-demand.
# This demonstrates the imperative approach using hyprctl dispatchers.
bind = SUPER, F, exec, hyprctl --batch "dispatch togglefloating ; dispatch centerwindow"
This example perfectly illustrates the imperative paradigm. It does not define a permanent policy for any specific application but provides a universal tool that can be applied to any window at any time by the user.15 A comprehensive list of available dispatchers can be found in the Hyprland Wiki.174.3 The Ultimate Escape Hatch: An Introduction to IPC with socatFor scenarios requiring logic more complex than what windowrule or simple dispatcher chains can provide, Hyprland exposes an Inter-Process Communication (IPC) socket. This socket broadcasts events about the state of the compositor, such as openwindow, closewindow, focusedmon, and more.18By using a standard utility like socat, it is possible to listen to this stream of events and trigger scripts in response. This opens the door to nearly limitless customization. For example, one could implement logic such as: "When a new terminal window opens, if it is the only window on the workspace, center it and make it larger; otherwise, tile it normally." This conditional logic is beyond the capability of a static windowrule.A conceptual script to achieve this might look as follows:Bash#!/usr/bin/env bash
#
# Conceptual script to demonstrate event-driven window management via IPC.
# This script listens for new windows and can execute hyprctl commands based
# on the window's properties.

socat - "UNIX-CONNECT:$XDG_RUNTIME_DIR/hypr/$HYPRLAND_INSTANCE_SIGNATURE/.socket2.sock" | while read -r line; do
  # The 'openwindow' event provides address, workspace, class, and title
  if [[ "$line" == "openwindow>>"*",kitty,"* ]]; then
    # Extract the window address (e.g., 0xdeadbeef) from the event line
    WINDOW_ADDRESS=$(echo "$line" | cut -d'>' -f3 | cut -d',' -f1)
    
    # Check how many windows are on the current workspace
    WINDOW_COUNT=$(hyprctl activeworkspace -j | jq '.windows')

    if]; then
      # If it's the only window, make it float, resize, and center it
      hyprctl --batch "dispatch setfloating address:$WINDOW_ADDRESS ; \
                       dispatch resizewindowpixel exact 1200 800,address:$WINDOW_ADDRESS ; \
                       dispatch centerwindow address:$WINDOW_ADDRESS"
    fi
  fi
done
While setting up such a script is significantly more involved, it serves as the ultimate escape hatch for implementing highly specific, state-aware automation that is impossible with other methods.20 It represents the pinnacle of Hyprland customization.To summarize the different approaches, the following table provides a comparative overview, serving as a decision-making framework for window management tasks.MethodUse CaseExecution TimingComplexityFlexibilitywindowruleSetting the initial state of new windows based on fixed criteria.On window creationLowMedium (limited by rule set)hyprctl dispatchManipulating existing windows on-demand via keybinds or simple scripts.Manual triggerMediumHigh (can chain any dispatcher)socat + IPCImplementing complex, conditional, state-aware logic based on compositor events.Event-drivenHighNear-infiniteThis framework clarifies that for the user's original request—ensuring 'Evil Launcher' always starts in a specific state—the windowrule is unequivocally the correct and most appropriate tool.Conclusion and Final RecommendationsThe analysis confirms that configuring an application to launch as a centered, floating window is a core competency of the Hyprland compositor, achieved primarily through its declarative windowrule system. The optimal solution is both robust and concise, leveraging a single line in the hyprland.conf file to define the desired initial state.The key to success lies in understanding the distinction between static and dynamic rules and correctly identifying a window's properties using hyprctl clients. Static rules such as float, center, and size are evaluated only at the moment of a window's creation and must be matched against the window's initialTitle or initialClass for reliable execution. Combining these directives into a single, well-targeted windowrule provides an idempotent and efficient policy.For the specific case of the 'Evil Launcher' application, the following configuration is recommended as the definitive solution. It not only fulfills the user's explicit request to float and center the window but also proactively addresses the common need for a predictable initial size, resulting in a more polished and practical user experience.Production-Ready Configuration:Code snippet#
# /home/<user>/.config/hypr/hyprland.conf
#
#################################################################
# WINDOW RULES FOR SPECIFIC APPLICATIONS
#################################################################
#
# This rule targets the 'Evil Launcher' application upon launch.
# It performs three actions in sequence:
# 1. float: Removes the window from the tiling layout.
# 2. center: Positions the floating window in the center of the monitor.
# 3. size 50% 40%: Resizes the floating window to 50% of the monitor's
#    width and 40% of its height.
#
# The rule is matched using 'initialTitle' to ensure it applies correctly
# at the moment the window is created. The '^' and '$' anchors ensure
# an exact title match.
#
windowrule = float, center, size 50% 40%, initialTitle:^(Evil Launcher)$
Finally, a strategic approach to window management in Hyprland can be summarized with a clear hierarchy of tools. One should always begin by attempting to solve the problem with a windowrule, as it is the simplest and most idiomatic method for defining initial window states. If the requirement is to manipulate a window after it has already been created, typically via a keybinding, the appropriate tool is a hyprctl dispatch command. For the most complex scenarios that involve conditional logic based on the compositor's state, the final recourse is to leverage the IPC socket with a tool like socat to create event-driven scripts. Adhering to this model will lead to clean, maintainable, and powerful Hyprland configurations.